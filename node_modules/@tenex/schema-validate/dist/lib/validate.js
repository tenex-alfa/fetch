"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
let ErrorPath = "";
let ErrorDescription = "";
const ErrorMessage = () => "Error on the Path: " + ErrorPath + ". " + ErrorDescription;
exports.ErrorMessage = ErrorMessage;
const parse = (input, template) => {
    return validateHelper(input, getSchema(template));
};
exports.parse = parse;
function getSchema(root) {
    if (typeof root !== "object")
        return getRestriction(root, true);
    const keys = Object.keys(root);
    const schema = {};
    for (const key of keys) {
        const lastKeyIndex = key.length - 1;
        const optional = key[lastKeyIndex] === "?";
        const letNewKey = !optional ? key : key.slice(0, key.length - 1);
        if (root[key].constructor.name == "Object") {
            schema[letNewKey] = {};
            if (optional) {
                schema[letNewKey] = getSchema(root[key]);
                schema[letNewKey].required = false;
            }
            else {
                schema[letNewKey] = getSchema(root[key]);
                schema[letNewKey].required = true;
            }
        }
        else {
            schema[letNewKey] = getRestriction(root[key], optional);
        }
    }
    return schema;
}
function getRestriction(object, optional) {
    if (object && object.constructor.name == "Array") {
        return {
            array: object.map(getSchema),
            type: Array,
            required: !optional
        };
    }
    return {
        array: [getJSNativeObject(object)],
        type: getJSNativeObject(object),
        required: !optional
    };
}
function getJSNativeObject(value) {
    switch ((value && value.toUpperCase && value.toUpperCase()) || value) {
        case "STRING":
            return String;
        case "NUMBER":
            return Number;
        case "BOOLEAN":
            return Boolean;
        case "OBJECT":
            return Object;
        default:
            return value;
    }
}
function validateHelper(input, template) {
    const type = template.type;
    const required = template.required;
    const array = template.array;
    if (input === undefined) {
        if (!required)
            return true;
        return false;
    }
    if (input === template)
        return true;
    if (!type) {
        for (const key in template) {
            const value = template[key];
            const res = validateHelper(input[key], value);
            if (!res)
                return res;
        }
        return true;
    }
    switch (type) {
        case String:
            return input.constructor.name == "String";
        case Boolean:
            return input.constructor.name == "Boolean";
        case Array:
            if (!Array.isArray(input))
                input = [input];
            for (const entry of input) {
                let correct = false;
                for (const arr of array) {
                    if (validateHelper(entry, arr))
                        correct = true;
                }
                if (!correct)
                    return false;
            }
            return true;
        case Number:
            return input.constructor.name == "Number";
    }
    if (type) {
        return input === type;
    }
    return false;
}
exports.default = parse;
